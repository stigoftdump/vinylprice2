<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vinyl Price Calculator</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
</head>

<body>

    <div class="main-container">
            <header>
                <div class="header-top-row">
                    <img src="{{ url_for('static', filename='images/oxfam-logo.png') }}" alt="Oxfam Logo" class="header-logo">
                    <div class="header-title-container">
                        <h1>Vinyl Price Calculator</h1>
                    </div>
                    <div class="header-spacer"></div>
                </div>
                {# Status message remains below the logo/title row #}
                {% set status_class = 'info' %}
                {% if status_message and 'Error' in status_message %}
                    {% set status_class = 'error' %}
                {% elif status_message and ('Completed' in status_message or 'calculated' in status_message) %}
                    {% set status_class = 'success' %}
                {% endif %}
                <div class="status-message {{ status_class if status_message else '' }} {{ 'show' if status_message else '' }}">
                    {{ status_message }}
                </div>
            </header>


        <div class="content-wrapper">
            <div class="left-column">
                <form method="POST">
                    <div class="paste-container">
                        <label for="pasted_discogs_data" class="paste-label label-with-tooltip">
                            <span>Paste Discogs Sales Data:</span>
                            <div class="tooltip-container">
                                <img src="{{ url_for('static', filename='images/info.svg') }}" alt="Info">
                                <span class="tooltip-text">Paste copied sales history from Discogs here.</span>
                            </div>
                        </label>
                        <textarea id="pasted_discogs_data" name="pasted_discogs_data" placeholder="Paste data here...">{{ pasted_discogs_data }}</textarea>
                    </div>

                    <div class="form-group">
                        <label for="media" class="label-with-tooltip">
                            <span>Media Condition:</span>
                             <div class="tooltip-container">
                                <img src="{{ url_for('static', filename='images/info.svg') }}" alt="Info">
                                <span class="tooltip-text">Select the grading for the vinyl/media itself.</span>
                            </div>
                        </label>
                        <select id="media" name="media">
                            <option value="9" {% if media == 9 %}selected{% endif %}>Mint (M)</option>
                            <option value="8" {% if media == 8 %}selected{% endif %}>Near Mint (NM or M-)</option>
                            <option value="7" {% if media == 7 %}selected{% endif %}>Very Good Plus (VG+)</option>
                            <option value="6" {% if media == 6 %}selected{% endif %}>Very Good (VG)</option>
                            <option value="5" {% if media == 5 %}selected{% endif %}>Good Plus (G+)</option>
                            <option value="4" {% if media == 4 %}selected{% endif %}>Good (G)</option>
                            <option value="3" {% if media == 3 %}selected{% endif %}>Fair (F)</option>
                            <option value="2" {% if media == 2 %}selected{% endif %}>Poor (P)</option>
                            <option value="1" {% if media == 1 %}selected{% endif %}>Generic / Not Graded / No Cover</option>
                        </select>
                    </div>

                    <div class="form-group">
                         <label for="sleeve" class="label-with-tooltip">
                            <span>Sleeve Condition:</span>
                             <div class="tooltip-container">
                                <img src="{{ url_for('static', filename='images/info.svg') }}" alt="Info">
                                <span class="tooltip-text">Select the grading for the record sleeve/cover.</span>
                            </div>
                        </label>
                        <select id="sleeve" name="sleeve">
                            <option value="9" {% if sleeve == 9 %}selected{% endif %}>Mint (M)</option>
                            <option value="8" {% if sleeve == 8 %}selected{% endif %}>Near Mint (NM or M-)</option>
                            <option value="7" {% if sleeve == 7 %}selected{% endif %}>Very Good Plus (VG+)</option>
                            <option value="6" {% if sleeve == 6 %}selected{% endif %}>Very Good (VG)</option>
                            <option value="5" {% if sleeve == 5 %}selected{% endif %}>Good Plus (G+)</option>
                            <option value="4" {% if sleeve == 4 %}selected{% endif %}>Good (G)</option>
                            <option value="3" {% if sleeve == 3 %}selected{% endif %}>Fair (F)</option>
                            <option value="2" {% if sleeve == 2 %}selected{% endif %}>Poor (P)</option>
                            <option value="1" {% if sleeve == 1 %}selected{% endif %}>Generic / Not Graded / No Cover</option>
                        </select>
                    </div>

                    <div class="form-group">
                         <label for="shop_var" class="label-with-tooltip">
                           <span>Shop Variance Factor:</span>
                             <div class="tooltip-container">
                                <img src="{{ url_for('static', filename='images/info.svg') }}" alt="Info">
                                <span class="tooltip-text">Adjusts the final price based on uncertainty (0.1-2.0). Lower=closer to prediction, Higher=closer to upper bound.</span>
                            </div>
                        </label>
                        <input type="number" id="shop_var" name="shop_var" value="{{ shop_var }}" step="0.1" min="0.1" max="2">
                    </div>

                    <div class="form-group date-add-group">
                         <div class="date-group">
                             <label for="start_date" class="label-with-tooltip">
                               <span>Include Sales From:</span>
                                 <div class="tooltip-container">
                                    <img src="{{ url_for('static', filename='images/info.svg') }}" alt="Info">
                                    <span class="tooltip-text">Only include sales data from this date onwards.</span>
                                </div>
                            </label>
                            <input type="date" id="start_date" name="start_Date" value="{{ start_date }}">
                         </div>
                         <div class="add-data-group">
                            <input type="checkbox" id="add_data" name="add_data" {% if add_data %}checked{% endif %}>
                             <label for="add_data" class="label-with-tooltip">
                                <span>Add to Previous Data</span>
                                <div class="tooltip-container">
                                    <img src="{{ url_for('static', filename='images/info.svg') }}" alt="Info">
                                    <span class="tooltip-text">Check this to merge the pasted data with data from the last calculation. Uncheck to replace.</span>
                                </div>
                            </label>
                        </div>
                    </div>

                    <input type="hidden" id="saved_discogs_data" name="saved_discogs_data">
                    <input type="hidden" id="selected_points_to_delete" name="selected_points_to_delete">

                    <div class="button-container">
                        <button type="submit" name="action" value="calculate">Estimate Price</button>
                        </div>

                </form>
            </div> <div class="right-column">
                 {% if calculated_price is not none or status_message and 'Error' in status_message %}
                 <div class="results-container">
                     <h2>Estimation Results:</h2>
                     {% if calculated_price == 'Error' or (calculated_price is none and status_message and 'Error' in status_message) %}
                        <p class="price-error"><strong>Calculation Error:</strong> {{ status_message }}</p>
                     {% elif calculated_price is not none %}
                        <p class="price-calculated"><strong>Predicted Price:</strong> £{{ calculated_price }}</p>
                        <p class="price-upper-bound"><strong>Max Price:</strong> £{{ adjusted_price }}</p>
                        <p class="price-actual"><strong>Suggested Price:</strong> £{{ actual_price }}</p>
                     {% endif %}
                 </div>

                {% if chart_data %}
                   <div class="chart-container">
                       <canvas id="myChart"></canvas>
                   </div>
                   <script id="chart-data-json" type="application/json">
                       {{ chart_data | tojson | safe }}
                   </script>
                {% endif %}

                 {% endif %}
            </div> </div> </div> {% if chart_data %}
    <script>
        // --- Chart.js Logic (largely unchanged, but check variable names) ---
        document.addEventListener('DOMContentLoaded', function() {
            const ctx = document.getElementById('myChart').getContext('2d');
            const jsonScriptTag = document.getElementById('chart-data-json');
            const jsonString = jsonScriptTag.textContent;
            const chartData = JSON.parse(jsonString);

            const labels = chartData.labels; // Quality labels (strings)
            const prices = chartData.prices; // Price values
            const predictedPrices = chartData.predicted_prices; // Best fit line prices
            const predictedQualities = chartData.predicted_qualities; // Best fit line qualities
            const reqscore = parseFloat(chartData.reqscore); // Requested quality score
            const predictedPrice = chartData.predicted_price; // Predicted price at reqscore
            const upperBound = chartData.upper_bound; // Upper bound at reqscore
            const actualPrice = chartData.actual_price; // Actual price at reqscore
            const dates = chartData.dates;
            const comments = chartData.comments;

            // Determine axis min/max dynamically but ensure reqscore is visible
            const all_qualities = labels.map(parseFloat).concat(predictedQualities.map(parseFloat));
            const minQualityInData = all_qualities.length > 0 ? Math.min(...all_qualities) : 1;
            const maxQualityInData = all_qualities.length > 0 ? Math.max(...all_qualities) : 9;
            const xAxisMin = Math.floor(Math.min(minQualityInData, reqscore)); // Ensure reqscore is included
            const xAxisMax = Math.ceil(Math.max(maxQualityInData, reqscore)); // Ensure reqscore is included

            let selectedPoints = []; // Array to hold selected points data

            function doPointsMatch(point1, point2) {
                const tolerance = 0.0001;
                return (
                    Math.abs(point1.quality - point2.quality) < tolerance &&
                    Math.abs(point1.price - point2.price) < tolerance &&
                    point1.date === point2.date &&
                    (point1.comment || "") === (point2.comment || "")
                );
            }

            function handlePointClick(event, elements, chart) {
                if (elements.length > 0) {
                    const clickedElement = elements[0];
                    const datasetIndex = clickedElement.datasetIndex;
                    const dataIndex = clickedElement.index;

                    // Only interact with the 'Items Sold' dataset (index 0)
                    if (datasetIndex === 0) {
                        const clickedPointData = {
                            quality: parseFloat(labels[dataIndex]),
                            price: prices[dataIndex],
                            date: dates[dataIndex],
                            comment: comments[dataIndex]
                        };

                        const selectedIndex = selectedPoints.findIndex(p => doPointsMatch(p, clickedPointData));

                        const backgroundColors = chart.data.datasets[datasetIndex].backgroundColor;

                        if (selectedIndex > -1) { // Point is selected -> Deselect
                            selectedPoints.splice(selectedIndex, 1);
                             // Ensure backgroundColors is an array before modifying
                            if (Array.isArray(backgroundColors)) {
                                backgroundColors[dataIndex] = 'red'; // Back to original color
                            } else { // If it's a single string, convert to array
                                chart.data.datasets[datasetIndex].backgroundColor = Array(prices.length).fill(backgroundColors);
                                chart.data.datasets[datasetIndex].backgroundColor[dataIndex] = 'red';
                            }
                        } else { // Point is not selected -> Select
                            selectedPoints.push(clickedPointData);
                             if (Array.isArray(backgroundColors)) {
                                backgroundColors[dataIndex] = 'black'; // Selected color
                            } else {
                                chart.data.datasets[datasetIndex].backgroundColor = Array(prices.length).fill(backgroundColors);
                                chart.data.datasets[datasetIndex].backgroundColor[dataIndex] = 'black';
                            }
                        }
                        chart.update(); // Update the chart visually
                    }
                }
            }


            function wrapText(text, maxLength) {
                if (!text) return [];
                const words = text.split(' ');
                let lines = [];
                let currentLine = '';
                words.forEach(word => {
                    if ((currentLine + word).length > maxLength) {
                        if (currentLine.length > 0) lines.push(currentLine.trim());
                        currentLine = word + ' ';
                    } else {
                        currentLine += word + ' ';
                    }
                });
                if (currentLine.length > 0) lines.push(currentLine.trim());
                return lines;
            }

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false, // Allow chart to resize height
                aspectRatio: 1.5, // Adjust aspect ratio if needed
                onClick: handlePointClick,
                plugins: {
                    title: {
                        display: true,
                        text: 'Price Calculation',
                        font: { size: 16, weight: '500' },
                        padding: { top: 10, bottom: 20 }
                    },
                legend: {
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        // --- Modified generateLabels function ---
                        generateLabels: function(chart) {
                            // Get the default labels generated by Chart.js (for datasets)
                            const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);

                            // Create a new array for custom labels
                            const customLabels = [
                                // Items Sold label (red circle)
                                {
                                    text: 'Items Sold',
                                    fillStyle: 'red',
                                    strokeStyle: 'red',
                                    lineWidth: 0,
                                    hidden: false,
                                    pointStyle: 'circle',
                                    index: 0
                                },
                                // Best Fit Curve label (blue line)
                                {
                                    text: 'Best Fit Curve',
                                    fillStyle: 'transparent',
                                    strokeStyle: 'blue',
                                    lineWidth: 2,
                                    hidden: false,
                                    pointStyle: undefined,
                                    index: 1
                                },
                                // Calculated Price label (orange dotted line)
                                {
                                    text: 'Calculated Price',
                                    fillStyle: 'transparent',
                                    strokeStyle: '#FFD700',
                                    lineWidth: 2,
                                    borderDash: [3, 3],
                                    hidden: false,
                                    pointStyle: undefined,
                                    lineDash: [3, 3],
                                    index: 2
                                },
                                // Max Price label (purple dotted line)
                                {
                                    text: 'Max Price',
                                    fillStyle: 'transparent',
                                    strokeStyle: 'purple',
                                    lineWidth: 2,
                                    borderDash: [3, 3],
                                    hidden: false,
                                    pointStyle: undefined,
                                    lineDash: [3, 3],
                                    index: 3
                                },
                                // Actual Price label (green circle)
                                {
                                    text: 'Actual Price',
                                    fillStyle: 'green',
                                    strokeStyle: 'green',
                                    lineWidth: 0,
                                    hidden: false,
                                    pointStyle: 'circle',
                                    index: 4
                                }
                            ];

                            return customLabels;
                        }
                    }
                },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleFont: { weight: 'bold' },
                        bodyFont: { size: 12 },
                        padding: 10,
                        cornerRadius: 6,
                        displayColors: false, // Don't show color box in tooltip
                        callbacks: {
                             label: function(context) {
                                let labelLines = [];
                                const index = context.dataIndex;

                                if (context.datasetIndex === 0) { // 'Items Sold' points
                                    const date = dates && dates[index] ? dates[index] : 'N/A';
                                    const price = prices && prices[index] !== undefined ? prices[index] : 'N/A';
                                    const comment = comments && comments[index] ? comments[index] : 'No comment';
                                    const qualityScore = labels && labels[index] ? parseFloat(labels[index]).toFixed(2) : 'N/A';

                                    let priceLabel = 'Price';
                                    if (date !== 'N/A') {
                                        const saleYear = new Date(date).getFullYear();
                                         // Use current year logic if needed
                                        const currentYear = new Date().getFullYear();
                                        if (saleYear < currentYear) {
                                            priceLabel = `Infl.-Adj. Price (from ${saleYear})`;
                                        } else {
                                             priceLabel = `Price (${saleYear})`;
                                        }
                                    }

                                    labelLines.push(`Date: ${date}`);
                                     labelLines.push(`Quality Score: ${qualityScore}`);
                                    labelLines.push(`${priceLabel}: ${new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(price)}`);

                                    if (comment && comment !== 'No comment') {
                                        const wrappedComment = wrapText(comment, 40);
                                        labelLines.push(`Comment: ${wrappedComment[0]}`);
                                        for (let i = 1; i < wrappedComment.length; i++) {
                                            labelLines.push(`  ${wrappedComment[i]}`);
                                        }
                                    } else if (comment === 'No comment'){
                                        labelLines.push(`Comment: ${comment}`);
                                    }

                                    return labelLines;
                                } else {
                                    // Default tooltip for lines (like Best Fit)
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                     if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    annotation: {
                        annotations: { // Use named annotations
                            predictedLine: {
                                type: 'line',
                                yMin: predictedPrice,
                                yMax: predictedPrice,
                                xMin: xAxisMin, // Start from axis
                                xMax: reqscore,
                                borderColor: 'orange',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: `Predicted: £${predictedPrice.toFixed(2)}`,
                                    enabled: true,
                                    position: 'start',
                                     backgroundColor: 'rgba(255,165,0,0.7)',
                                    color: 'black',
                                    font: { size: 10 },
                                     yAdjust: -10
                                }
                            },
                             upperBoundLine: {
                                type: 'line',
                                yMin: upperBound,
                                yMax: upperBound,
                                xMin: xAxisMin,
                                xMax: reqscore,
                                borderColor: 'purple',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    content: `Upper Bound: £${upperBound.toFixed(2)}`,
                                    enabled: true,
                                    position: 'start',
                                    backgroundColor: 'rgba(128,0,128,0.7)',
                                    color: 'white',
                                    font: { size: 10 },
                                    yAdjust: 10
                                }
                            },
                            actualPriceLine: {
                                type: 'line',
                                yMin: actualPrice,
                                yMax: actualPrice,
                                xMin: xAxisMin,
                                xMax: reqscore,
                                borderColor: 'green',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                 label: {
                                    content: `Suggested: £${actualPrice.toFixed(2)}`,
                                    enabled: true,
                                    position: 'start',
                                    backgroundColor: 'rgba(0,128,0,0.7)',
                                     color: 'white',
                                    font: { size: 10 },
                                     yAdjust: 0 // Adjust as needed based on other labels
                                }
                            },
                            reqScoreLine: { // Vertical line at reqscore
                                type: 'line',
                                xMin: reqscore,
                                xMax: reqscore,
                                yMin: 0, // Start from bottom axis
                                yMax: actualPrice, // Go up to the actual price line
                                borderColor: 'green',
                                borderWidth: 2
                            },
                            intersectionPoint: { // Point at intersection
                                type: 'point',
                                xValue: reqscore,
                                yValue: actualPrice,
                                backgroundColor: 'green',
                                radius: 6
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Combined Quality Score',
                            font: { size: 14, weight: '500'}
                        },
                        type: 'linear', // Ensure x-axis is treated linearly
                        min: xAxisMin,
                        max: xAxisMax,
                         ticks: {
                             stepSize: 1,
                             callback: function(value, index, values) {
                                const qualityMap = {
                                        1: 'Gen/NG',
                                        2: 'Poor',
                                        3: 'Fair',
                                        4: 'Good',
                                        5: 'Good+',
                                        6: 'Very Good',
                                        7: 'Very Good+',
                                        8: 'Near Mint',
                                        9: 'Mint'
                                };
                                // Show integer ticks and map them
                                if (Number.isInteger(value) && value >= 1 && value <= 9) {
                                     return qualityMap[value] || value;
                                }
                                // Don't show labels for non-integer ticks unless needed
                                return null;
                             },
                            font: { size: 12 }
                         },
                        grid: {
                            color: '#eee' // Lighter grid lines
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Price (£, Inflation Adjusted)',
                             font: { size: 14, weight: '500'}
                        },
                        beginAtZero: true,
                        ticks: {
                            callback: function(value, index, values) {
                                return '£' + value.toFixed(0); // Simpler price ticks
                            },
                             font: { size: 12 }
                        },
                         grid: {
                            color: '#eee' // Lighter grid lines
                        }
                    }
                }
            };

            const myChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    // Labels array is still needed for tooltip mapping by index, even if x is linear
                    labels: labels, // Keep original labels for reference
                    datasets: [{
                            label: 'Items Sold',
                            data: labels.map((label, index) => ({
                                x: parseFloat(label), // Use numeric quality for position
                                y: prices[index]
                            })),
                            borderColor: 'rgba(255, 0, 0, 0.3)', // More subtle border
                            backgroundColor: Array(prices.length).fill('red'), // Initial point color (managed by click handler)
                            pointRadius: 5,
                            pointHoverRadius: 7,
                        },
                        {
                            label: 'Best Fit Curve',
                            data: predictedQualities.map((qual, index) => ({
                                x: parseFloat(qual),
                                y: predictedPrices[index]
                            })),
                            borderColor: 'blue',//var(--chart-fit-color)',
                            borderWidth: 2.5,
                            pointRadius: 0, // No points on the line itself
                            fill: false,
                            tension: 0.3, // Smoother curve
                            type: 'line',
                            showLine: true
                        }
                         // Dashed lines for annotations are handled by the annotation plugin now
                    ]
                },
                options: chartOptions
            });

            // --- Form Submission Logic (Handles hidden inputs) ---
            const form = document.querySelector('form');
            form.addEventListener('submit', function(event) {
                const pastedTextarea = document.getElementById('pasted_discogs_data');
                const hiddenDiscogsInput = document.getElementById('saved_discogs_data');

                // Ensure both elements exist before proceeding
                if (hiddenDiscogsInput && pastedTextarea) {
                    const discogsData = pastedTextarea.value;

                    // Check if the textarea content is NOT just whitespace or empty
                    if (discogsData.trim() !== '') {
                        // If the textarea has content, copy it to the hidden field
                        hiddenDiscogsInput.value = discogsData;
                        console.log("Textarea has data, copied to hidden field.");
                    } else {
                        // If the textarea is blank, keep the current value in the hidden field
                        console.log("Textarea is blank, keeping existing data in hidden field.");
                        // No need to do anything here, the hidden field's value remains unchanged
                    }
                } else {
                    console.error("Hidden input 'saved_discogs_data' or textarea 'pasted_discogs_data' not found!");
                }

                // Keep the logic for the selected points data
                const selectedPointsInput = document.getElementById('selected_points_to_delete');
                if (selectedPointsInput) {
                    // Assuming selectedPoints is managed elsewhere in your script
                    if (typeof selectedPoints !== 'undefined') {
                         selectedPointsInput.value = JSON.stringify(selectedPoints);
                    } else {
                         console.warn("selectedPoints variable not found. Cannot serialize for deletion.");
                         selectedPointsInput.value = '[]'; // Default to empty array JSON
                    }

                } else {
                     console.error("Hidden input 'selected_points_to_delete' not found!");
                }
            });
        });

    </script>
    {% endif %}

     <script>
        let formSubmitted = false;
        document.querySelector('form').addEventListener('submit', function() {
            formSubmitted = true;
        });
        window.addEventListener('beforeunload', function (e) {
            if (!formSubmitted) {
                // Use navigator.sendBeacon for reliable background sending
                navigator.sendBeacon('/shutdown', ''); // Send empty body is fine for POST trigger
            }
        });
    </script>

</body>
</html>